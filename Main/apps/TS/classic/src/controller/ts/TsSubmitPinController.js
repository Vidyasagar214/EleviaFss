Ext.define('TS.controller.ts.TsSubmitPinController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.window-tssubmitpin',

    config: {
        sprite: null
    },

    sigDown: false,
    lastEventX: undefined,
    lastEventY: undefined,
    list: [],

    /**
     * Called when the view is created
     */
    init: function () {
    },

    tsSubmitPinClick: function () {
        var me = this,
            settings = TS.app.settings,
            pin = me.lookup('tsSubmitPinField').getValue(),
            form = me.lookup('tsSubmitPinForm').getForm(),
            view = me.getView(),
            button = me.lookup('tsSubmitPinBtn');
        //
        // if (!me.lastEventX || !view.lookup('tsSubmitPinField').getValue()) {
        //     Ext.MessageBox.alert('Warning', 'PIN and Signature are both required');
        //     button.setDisabled(true);
        //     return;
        // }
        me.doSaveSignature();
        // if (form.isValid()) {
        //     User.AuthenticatePin(window.userGlobal.dbi, pin, window.userGlobal.email, function (response, operation, success) {
        //         if (response.data) {
        //             //save signature
        //             me.doSaveSignature();
        //         } else {
        //             Ext.GlobalEvents.fireEvent('Message:Code', 'tsSubmitPinBadField');
        //             me.lookup('tsSubmitPinField').setValue('');
        //             me.getView().setLoading(false);
        //         }
        //     }, me, {
        //         autoHandle: true
        //     });
        // } else {
        //     Ext.GlobalEvents.fireEvent('Message:Code', 'tsSubmitPinMissingFields');
        //     me.getView().setLoading(false);
        // }
    },

    /*mouse - touch events*/
    onMouseDown: function (e) {

        this.sigDown = true;
        var sprite = this.getSprite();
        if (sprite) {
            var xy = this.lookup('sigDrawPanel').getSurface().getEventXY(e);
            sprite.setAttributes({
                path: sprite.attr.path + ' M' + (xy[0]) + ',' + (xy[1])
            });
        }
    },

    onMouseMove: function (e) {
        if (this.sigDown) {

            var drawing = this.lookup('sigDrawPanel'),
                xy = drawing.getSurface().getEventXY(e);
            this.lastEventX = xy[0];
            if (!this.getSprite()) {
                var sprite = drawing.getSurface().add({
                    type: 'path',
                    path: 'M' + (xy[0]) + ',' + (xy[1]),
                    strokeStyle: 'black',
                    lineWidth: 2,
                    lineCap: 'round'
                }).show();
                this.setSprite(sprite);
            } else {
                var sprite = this.getSprite(),
                    path = sprite.attr.path;
                path += ' ' + (xy[0]) + ',' + (xy[1]);
                sprite.setAttributes({
                    path: path
                });
            }
            drawing.getSurface().renderFrame();
        }
    },

    onMouseUp: function (e) {
        var button = this.lookup('tsSubmitPinBtn');
        button.setDisabled(false);
        this.sigDown = false;
        this.setSprite(null);
    },

    tsSubmitPinCancel: function () {
        this.getView().close();
    },

    doSaveSignature: function () {
        // Get the references and image data, convert to blob
        var me = this,
            view = me.getView(),
            attType = view.attType,
            draw = me.lookup('sigDrawPanel'),
            imageData = draw.getImage('stream'),
            settings = TS.app.settings,
        //Get image data, convert to blob
            file = new Blob([imageData.data], {
                type: 'image/' + imageData.type
            }),
        //Get attachment data
            data = {
                type: 'TS',
                location: settings.imageStorageLoc,
                associatedId: this.getView().associatedRecordId,
                attachmentType: this.getView().attType,
                fileExt: imageData.type,
                fileName: 'signature_' + Ext.data.identifier.Uuid.Global.generate(), // TODO - How should this be autogenerated?
                description: settings.tsTitle + ' Approval Signature',
                file: file
            };
        //Create attachment and submit timesheet
        me.convertFileToByteData(data.file, Ext.bind(function (byteData) {
            var attachmentRecord = Ext.create('TS.model.shared.Attachment', {
                owningModelType: data.type,
                owningModelId: data.associatedId + '||' + settings.empId,
                dateAttached: data.date || new Date(),
                attachmentType: data.attachmentType,
                location: data.location,
                extension: data.fileExt,
                filename: data.fileName,
                description: data.description,
                attachmentItem: byteData
            });

            if (!view.tsEmployee) {
                Ext.GlobalEvents.fireEvent('SubmitAfterPinCheck', view.button, view.event, attachmentRecord);
            } else {
                Ext.GlobalEvents.fireEvent('SubmitEmployeeAfterPinCheck', view.button, view.event, attachmentRecord);
            }

            me.getView().close();

        }, me));
    },

    // Removes all sprites from the draw panel
    doClearSignature: function () {
        this.lookup('sigDrawPanel').removeAll();
        this.lastEventX = null;
        var button = this.lookup('tsSubmitPinBtn');
        button.setDisabled(true);
    },
    /*
     * Helper Methods
     */
    convertFileToByteData: function (file, callback) {
        var reader = new FileReader();
        reader.onload = (function (file) {
            return function (e) {
                // Convert to plain array for sending through to Ext.Direct
                var byteArray = new Uint8Array(e.target.result),
                    returnArray = [];
                for (var i = 0; i < byteArray.length; i++) {
                    returnArray[i] = byteArray[i];
                }
                callback(returnArray);
            };
        })(file);
        reader.readAsArrayBuffer(file);
    }
});